var documenterSearchIndex = {"docs":
[{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#QuantumGaussianDynamics.Dynamics","page":"API","title":"QuantumGaussianDynamics.Dynamics","text":"Settings for the dynamics.\n\nDynamics(dt :: T = 1.0  #femtosecodns,     totaltime :: T # In femtosecodns,     algorithm :: String = \"generalized-verlet\",     kongliuratio :: T = 1.0,     verbose :: Bool = true,     evolvecorrelators :: Bool = true,     correlated :: Bool = true,     seed :: Int64,     N :: Int64,\n\n# Save the data each\nsave_each :: Int64 = 1,\nsave_filename :: String,\nsave_correlators :: Bool)\n\nThe settings for the simulation. dt and total_time are in femtoseconds\n\ndt is the time step [in femtoseconds]\ntotal_time is the total simulation time [in femtoseconds]\nalgorithm is the integration algorithm to use. Either \"generalized-verlet\" or \"semi-implicit-verlet\"\nkong_liu_ratio is the ratio exploits the importance sampling.\nverbose is a flag to print out information during the simulation\nevolve_correlators is a flag to evolve the correlators <RR>, <PP> and <RP>\ncorrelated if true, the correlated approach for computing ensemble averages is used\nseed is the seed for the random number generator\nN is the number of stochastic configurations\nsave_filename is the name of the file where to save the data\nsave_correlators is a flag to save the correlators information\nsave_each is the number of steps between each save of the data\n\n\n\n\n\n","category":"type"},{"location":"api.html#QuantumGaussianDynamics.ElectricField","page":"API","title":"QuantumGaussianDynamics.ElectricField","text":"Electric Field.\n\nBase.@kwdef mutable struct ElectricField{T <: AbstractFloat} \n    fun :: Function #Time in fs, unit \n    Zeff :: Matrix{T} \n    edir :: Vector{T} #Must have unit norm\n    eps :: Matrix{T}\nend\n\nThis structure contains the information about the external IR electric field.\n\nfun is the function that describes the electric field as a function of time\nZeff is the effective charge matrix\nedir is the direction of the electric field\neps is the dielectric constant matrix\n\n\n\n\n\n","category":"type"},{"location":"api.html#QuantumGaussianDynamics.Ensemble","page":"API","title":"QuantumGaussianDynamics.Ensemble","text":"Ensemble average information stocastic displacements and forces have index i, j, coordinate i, configuration j\n\nEnsemble(rho0 :: WignerDistribution{T},     positions :: Matrix{T},  # Positions are multiplied by the square root of the masses     energies :: Vector{T},     forces :: Matrix{T}, # Forces are divided by the squareroot of masses     stress :: Matrix{T}, # Stress in eV/A^3     sschaenergies :: Vector{T},     sschaforces :: Matrix{T},     nconfigs :: Int32,     weights :: Vector{T},     temperature :: T,     correlated :: Bool,     y0 :: Matrix{T},     #unitcell :: Matrix{T})\n\n\n\n\n\n","category":"type"},{"location":"api.html#QuantumGaussianDynamics.WignerDistribution","page":"API","title":"QuantumGaussianDynamics.WignerDistribution","text":"The WignerDistribution.\n\nIt can be initialized using the method init_from_dyn. Alternatively, one can initialize a generic one with the field\n\nWignerDistribution(n_atoms; type = Float64, n_dims=3)\n\nThe structure contains the following fields:\n\nBase.@kwdef mutable struct WignerDistribution{T<: AbstractFloat}\n    R_av    :: Vector{T}\n    P_av    :: Vector{T}\n    masses  :: Vector{T}\n    n_atoms :: Int\n    n_modes :: Int\n    RR_corr :: Matrix{T}\n    PP_corr :: Matrix{T}\n    RP_corr :: Matrix{T}\n    alpha :: Matrix{T}\n    beta :: Matrix{T}\n    gamma   :: Matrix{T}\n    \n    settings :: GeneralSettings\n    λs :: Vector{T}\n    λs_vect :: Matrix{T}\n    evolve_correlators :: Bool\n    cell :: Matrix{T}\n    atoms :: Vector{String}\nend\n\nNote that all the variable here are with a tilde (mass rescaled) So that we can use linear-algebra on them quickly.\n\n\n\n\n\n","category":"type"},{"location":"api.html#QuantumGaussianDynamics.calculate_ensemble!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.Ensemble{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.calculate_ensemble!","text":"calculate_ensemble!(ensemble::Ensemble{T}, crystal) where {T<:AbstractFloat}\n\nEvaluate energies, forces, and stresses for each configuration in an Ensemble using a given calculator ( assigned to crystal). Results are written back into the ensemble in place.\n\nArguments\n\nensemble::Ensemble{T}: ensemble of stochastic configurations. Updated in place.\ncrystal: external calculator object (e.g. ASE/PyCall wrapper) providing:\ncrystal.positions (settable Cartesian coordinates)\nget_potential_energy()\nget_forces() (returns N_atoms × 3 array)\nget_stress() (returns stress tensor\n\nUnits\n\nEnergies are converted to Rydberg (* CONV_RY).\nForces are flattened, divided by √masses, and converted with CONV_RY/CONV_BOHR.\nStress is assumed to be in eV/Å³ and stored directly.\n\nReturns\n\nThe updated ensemble (modification is in place, return value is mainly for chaining).\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.classic_evolution!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Any, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.classic_evolution!","text":"classicevolution!(Rs::Vector{T}, Ps::Vector{T}, dt::T, clfor, part) where {T <: AbstractFloat}\n\nClassic dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.euler_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.euler_step!","text":"eulerstep!(wigner:: WignerDistribution{T}, dt :: T, avgfor :: Vector{T}, d2V_dr2 :: Matrix{T}) where {T <: AbstractFloat}\n\nExplicit Euler method. Implemented for testing and didactic use. MUST BE AVOIDED, it is unconditionally unstable. \n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.fixed_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.fixed_step!","text":"function fixedstep!(wigner :: WignerDistribution{T}, dt :: T, avgfor :: Vector{T}, d2V_dr2 :: Matrix{T},part ) where {T <: AbstractFloat}\n\nEvolves the quantum state freezing the nuclear degrees of freedom. This corresponds to a classic evolution  in which however the forces are computed as ensemble averages using the initial quantum distribution.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.full_generalized_verlet_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}, Vector{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.full_generalized_verlet_step!","text":"semiimpliciteulerstep!(wigner:: WignerDistribution{T}, dt :: T, avgfor :: Vector{T}, d2V_dr2 :: Matrix{T}) where {T <: AbstractFloat}\n\nExperimental.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.generalized_verlet_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.generalized_verlet_step!","text":"generalized_verlet_step!(rho :: WignerDistribution{T}, dt :: T, avg_for :: Vector{T}, d2V_dr2 :: Matrix{T}, bc0 :: Vector{T} ,part ) where {T <: AbstractFloat}\n\nEvolves the means and second–order correlators of a WignerDistribution by one generalized-Verlet step. This is algorithm has O(dt^3) error in time step.  The algorithnm is illustrated in the work from Libbi et al., npj Computat. Mater. 11, 102 (2025), and consists of the explicit evolution of the variables ⟨R⟩, ⟨P⟩ and ⟨RR⟩, and of an implicit evolution for the variables ⟨PP⟩ and ⟨RP⟩. The latter is performed iteratively. \n\nArguments\n\nrho::WignerDistribution{T}: state (means & correlators), updated in place.\ndt::T: time step.\navg_for::Vector{T}: current average force ⟨f⟩.\nd2V_dr2::Matrix{T}: Hessian (∂²V). Assumed symmetric in practice.\npart::Int: stage selector (1 = predictor, 2 = corrector).\n\nGiven the following variables name ⟨R⟩   = Rav, ⟨P⟩   = Pav, ⟨f⟩   = avgfor, ⟨RR⟩  = RRcorr, ⟨PP⟩  = PPcorr, ⟨RP⟩  = RPcorr, ⟨d²V⟩ = d2V_dr2\n\npart == 1 (predictor):\nMeans (half-kick)\n⟨R⟩ ← ⟨R⟩ + dt⟨P⟩ + ½dt²*⟨f⟩\n⟨P⟩ ← ⟨P⟩ + ½dt⟨f⟩\nCorrelators\nlet  K = ⟨RR⟩ * ⟨d²V⟩\n⟨RR⟩ ← ⟨RR⟩ + dt(⟨RP⟩ + ⟨RP⟩ᵀ) − ½dt²(K + Kᵀ) + dt²⟨PP⟩\nsave ⟨RP⟩₀ = ⟨RP⟩\n⟨RP⟩ ← ⟨RP⟩ + ½dt(⟨PP⟩ − K)\n⟨PP⟩ ← ⟨PP⟩ − ½dt(⟨d²V⟩⟨RP⟩₀ + (⟨d²V⟩⟨RP⟩₀)ᵀ)\npart == 2 (corrector / finishing kick):\nMeans\n⟨P⟩ ← ⟨P⟩ + ½dt⟨f⟩\nCorrelators (fixed-point refinement of ⟨PP⟩ and ⟨RP⟩)\npre-update: ⟨RP⟩ ← ⟨RP⟩ − ½dt(⟨RR⟩*⟨d²V⟩)\niterate a few times (typically 4):\n⟨RP⟩₁ ← ⟨RP⟩ + ½dt⟨PP⟩₁\n⟨PP⟩₁ ← ⟨PP⟩ − ½dt(⟨d²V⟩⟨RP⟩₁ + (⟨d²V⟩⟨RP⟩₁)ᵀ)\nwrite back final ⟨PP⟩, ⟨RP⟩\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.generate_ensemble!-Union{Tuple{T}, Tuple{Any, QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.WignerDistribution{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.generate_ensemble!","text":"generate_ensemble!(N, ensemble:: Ensemble{T}, wigner_distribution :: WignerDistribution{T}) where {T <: AbstractFloat}\n\nGenerate or update an ensemble of stochastic configurations for nuclear dynamics, based on a Wigner distribution.\n\nArguments\n\nN::Int: Number of configurations to generate (must be even).\nensemble::Ensemble{T}: Target ensemble structure. Arrays are either updated in place if their size already matches N, or reallocated otherwise.\nwigner_distribution::WignerDistribution{T}: Wigner distribution that encodes the covariance matrices, eigenvalues, and eigenvectors used to generate the ensemble.\n\nBehavior\n\nIf ensemble.correlated == true, correlated configurations are generated from ensemble.y0 using the square root of the correlator matrix.\nOtherwise, random Gaussian vectors are drawn (using randn) and scaled by √λ or 1/√λ depending on whether ρ.evolve_correlators is set.\nIn MPI runs, random numbers are generated on rank 0 and broadcast to all ranks so that every processor works with the same ensemble.\n\nReturns\n\nThe updated ensemble (modifications are in place).\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_average_energy-Union{Tuple{QuantumGaussianDynamics.Ensemble{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_average_energy","text":"get_average_energy(ensemble :: Ensemble{T}) where {T <: AbstractFloat}\n\nComputes the ensemble average of the potential energy. \n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_average_forces-Union{Tuple{QuantumGaussianDynamics.Ensemble{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_average_forces","text":"get_average_forces(ensemble :: Ensemble{T}) where {T <: AbstractFloat}\n\nComputes the ensemble average of the forces. \n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_average_stress-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.WignerDistribution{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_average_stress","text":"get_average_stress(ensemble :: Ensemble{T}, wigner :: WignerDistribution{T}) where {T <: AbstractFloat}\n\nComputes the ensemble average of the stress.  The result is returned in Ry/Bohr^3\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_averages!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.WignerDistribution{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_averages!","text":"function getaverages!(avgfor :: Vector{T}, d2vdr2 :: Matrix{T}, ensemble :: Ensemble{T}, wignerdistribution :: WignerDistribution{T}) where {T <: AbstractFloat}\n\nEvaluate the average force and d2v_dr2 from the ensemble and the wigner distribution. The weights on the ensemble should have been already updated.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_classic_forces-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_classic_forces","text":"get_classic_forces(wigner_distribution:: WignerDistribution{T}, crystal) where {T <: AbstractFloat}\n\nCompute the forces at the centroids, i.e., the classical forces acting on the crystal.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_kong_liu-Union{Tuple{QuantumGaussianDynamics.Ensemble{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_kong_liu","text":"get_kong_liu(ensemble :: Ensemble{T}) where {T <: AbstractFloat}\n\nCompute the Kong-Liu ration\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_random_y-Union{Tuple{T}, Tuple{Any, Any, QuantumGaussianDynamics.Dynamics{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_random_y","text":"get_random_y(N, N_modes, settings :: Dynamics{T}) where {T <: AbstractFloat}\n\nGenerates a random matrix of numbers sampled from a normal distribution. Each row corresponds to a phonon mode, and contains N random configurations (or N/2 if evenodd = true). For parallel execution, the matrix ymui is broadcast so that all processors use the same random variables.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_total_energy-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.WignerDistribution{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_total_energy","text":"get_total_energy(ensemble :: Ensemble{T}, wigner_distribution :: WignerDistribution{T}) where {T <: AbstractFloat}\n\nComputes the total quantum energy, as a sum of the quantum potential energy (avgene), quantum kynetic energy (Krho), and classic kynetic energy (K_point)\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.get_λs-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.get_λs","text":"function get_λs(RR_corr :: Matrix{T}) where {T <: AbstractFloat}\n\nGet the eigenvalues of <RR>.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.init_ensemble_from_python-Union{Tuple{T}, Tuple{Any, QuantumGaussianDynamics.Dynamics{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.init_ensemble_from_python","text":"init_ensemble_from_python(py_ensemble, settings::Dynamics{T}) where {T<:AbstractFloat}\n\nConstruct a Julia Ensemble object from a Python-side ensemble exported via PyCall.\n\nThis routine converts positions, forces, stresses, and energies from the Python py_ensemble (typically created by CellConstructor / SSCHA Python codes) into the internal representation used by QuantumGaussianDynamics.\n\nArguments\n\npy_ensemble: A Python object with fields:\ncurrent_dyn    – Python dynamical matrix object\nT0             – temperature (in K)\nN              – number of configurations\nxats           – atomic random displacements, shape (N, Nat, 3)\nenergies       – raw energies for each configuration\nsscha_energies – SSCHA energies\nforces         – atomic forces, shape (N, Nat, 3)\nsscha_forces   – SSCHA forces, shape (N, Nat, 3)\nstresses       – stress tensors, shape (N, 3, 3)\n\nConversions performed\n\nPositions: (Nat, 3, N) → (3*Nat, N). Converted to Bohr and multiplied by √masses.\nEnergies: copied directly from py_ensemble.energies and sscha_energies.\nForces: (Nat, 3, N) → (3*Nat, N). Converted to Ry/Bohr and divided by √masses.\nStresses: (3,3) tensors packed into 6×N Voigt form:   1=xx, 2=yy, 3=zz, 4=yz, 5=xz, 6=xy.\nWeights: initialized to 1.0 for all configurations.\nRandom seed: if settings.seed != 0, reseeds RNG for reproducibility.\ny0: initial random Gaussian vectors, generated with get_random_y. If settings.correlated==false, filled with zeros of the correct shape.\n\nReturns\n\nEnsemble{T}: A new ensemble populated with data from Python, ready for use in QuantumGaussianDynamics simulations.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.init_from_dyn-Union{Tuple{T}, Tuple{Any, T, QuantumGaussianDynamics.Dynamics{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.init_from_dyn","text":"init_from_dyn(dyn, TEMPERATURE::T, settings::Dynamics{T}) where {T<:AbstractFloat}\n\nInitialize a WignerDistribution object starting from a dynamical matrix.\n\nThis routine constructs the equilibrium nuclear quantum state (in terms of positions, momenta, and correlation matrices) associated with the phonon modes of the provided dynamical matrix at a given temperature.\n\nArguments\n\ndyn: A dynamical matrix object from SSCHA calculations\nTEMPERATURE::T: The target temperature.\nsettings::Dynamics{T}: Simulation settings.\n\nDetails\n\nBuilds a supercell from dyn and computes the number of modes and atoms.\nDiagonalizes the supercell dynamical matrix to obtain phonon frequencies and eigenvectors (polarizations).\nComputes Gaussian width parameters (alpha, beta) and correlators (RR_corr, PP_corr, RP_corr) at the specified temperature.\nInitializes average positions (R_av) and momenta (P_av), rescaled by atomic masses.\nRemoves translational acoustic modes from the correlators/eigenvalues.\n\nReturns\n\nrho::WignerDistribution: An initialized Wigner distribution representing the quantum nuclear state corresponding to the given dynamical matrix and temperature.\n\nNotes\n\nFrequencies are assumed to be in Rydberg units.\nCell vectors and coordinates are converted to Bohr units.\nIf settings.evolve_correlators == false, eigen-decomposition of alpha is used; otherwise, the RR_corr matrix is diagonalized (deprecated).\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.integrate!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.Dynamics{T}, Any, QuantumGaussianDynamics.ElectricField{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.integrate!","text":"integrate!(wigner::WignerDistribution{T},\n           ensemble::Ensemble{T},\n           settings::Dynamics{T},\n           crystal,\n           efield::ElectricField{T}) where {T<:AbstractFloat}\n\nTime-integrate the TDSCHA equations of motion. This mutates wigner (⟨R⟩, ⟨P⟩, correlators) and ensemble (weights, possibly regenerated configurations), and writes diagnostics to disk at the cadence settings.save_each.\n\nIntegration scheme\n\nUses the algorithm specified by settings.algorithm: \"euler\" | \"semi-implicit-euler\" | \"semi-implicit-verlet\" | \"fixed\" | \"generalized-verlet\" | \"none\".\nAt each step:\nBuild average force and Hessian‐like term from the current ensemble: get_averages!.\nAdd external field forces get_external_forces(t_fs, efield, wigner).\nAdvance quantum variables with the selected integrator.\nAdvance classical centroids (Rs, Ps) via classic_evolution!.\nUpdate eigenstructure of RR and reweight the ensemble update_weights!.\nIf the Kong–Liu ratio falls below settings.kong_liu_ratio, regenerate the ensemble and recompute forces.\n\nFiles written (rank 0 only)\n\nAll prefixed by settings.save_filename * \"settings.dt-settings.total_time-settings.N\": All in Rydberg units, NOT scaled by masses. \n\n.pos: ⟨R⟩ and ⟨P⟩ plus total energy.\n.rho: RR correlator.\n.for: average force and “classical” force, and d²V/dR².\n.cl: classical centroids and classical energy.\n.ext: external field force.\n.str: average Voigt stress.\n.bet: PP correlator.\n.gam: RP correlator.\n\nReturns\n\nnothing. The function mutates wigner, ensemble, and writes output files.\n\nErrors\n\nThrows ArgumentError if settings.algorithm is unknown.\n\nExample\n\n```julia w   = WignerDistribution{Float64}(; ... )   # prepared from a phonon dyn ens = Ensemble{Float64}(; ... )             # configurations & weights ef  = ElectricField{Float64}(; fun=t->exp(-(t-50)^2/200), Zeff=Z, edir=û, eps=ϵ) integrate!(w, ens, Dynamics(dt=1.0, totaltime=200.0, algorithm=\"generalized-verlet\",                             kongliuratio=0.8, verbose=true, correlated=true,                             seed=1, N=size(ens.positions,2), saveeach=50,                             save_filename=\"run\"), crystal, ef)\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.pulse-NTuple{5, Any}","page":"API","title":"QuantumGaussianDynamics.pulse","text":"pulse(t, A, w, t0, sig)\n\nGaussian wavepacket pulse\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.remove_translations-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, T}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.remove_translations","text":"Remove acoustic sum rule from eigenvalue and eigenvectors\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.semi_implicit_euler_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.semi_implicit_euler_step!","text":"semiimpliciteulerstep!(wigner:: WignerDistribution{T}, dt :: T, avgfor :: Vector{T}, d2V_dr2 :: Matrix{T}) where {T <: AbstractFloat}\n\nSemi-implicit Euler method. Implemented for testing and didactic use. Not efficient, use semi-implicit Verlet instead.\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.semi_implicit_verlet_step!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.WignerDistribution{T}, T, Vector{T}, Matrix{T}, Any}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.semi_implicit_verlet_step!","text":"function semi_implicit_verlet_step!(rho:: WignerDistribution{T}, dt :: T, avg_for :: Vector{T}, d2V_dr2 :: Matrix{T}, part ) where {T <: AbstractFloat}\n\nEvolves the quantum means and correlators of a WignerDistribution by one semi-implicit Verlet integration step. This algorithms has error O(dt^2) on  the integration of the correlators. \n\nThis is a two-stage scheme:  \n\npart == 1 updates the positions (R_av) and momenta (P_av) using the current force avg_for.  \npart == 2 completes the step with the updated force, and evolves the second-order correlators (RR_corr, RP_corr, PP_corr).\n\nArguments\n\nρ::WignerDistribution{T}: system state (means and correlators), mutated in place.\ndt::T: time step.\navg_for::Vector{T}: average force vector ⟨F⟩.\nd2V_dr2::Matrix{T}: Hessian (second derivatives of the potential).\npart::Int: integration stage:\n\nMethod\n\nGiven the following variables name ⟨R⟩   = Rav, ⟨P⟩   = Pav, ⟨f⟩   = avgfor, ⟨RR⟩  = RRcorr, ⟨PP⟩  = PPcorr, ⟨RP⟩  = RPcorr, ⟨d²V⟩ = d2V_dr2\n\nIn part == 1:\n⟨R⟩ ← ⟨R⟩ + dt·⟨P⟩ + ½·dt²·⟨f⟩\n⟨P⟩ ← ⟨P⟩ + ½·dt·⟨f⟩\nIn part == 2:\n⟨P⟩ ← ⟨P⟩ + ½·dt·⟨f⟩\n⟨RP⟩ ← ⟨RP⟩ + dt·⟨PP⟩ − dt·⟨RR⟩·⟨d²V⟩\n⟨PP⟩ ← ⟨PP⟩ − dt·(⟨d²V⟩·⟨RP⟩ + (⟨d²V⟩·⟨RP⟩)ᵀ)\n⟨RR⟩ ← ⟨RR⟩ + dt·(⟨RP⟩ + ⟨RP⟩ᵀ)\n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.sin_field-Tuple{Any, Any, Any}","page":"API","title":"QuantumGaussianDynamics.sin_field","text":"sin_field(t, A, w)\n\nSinusoidal external field. \n\n\n\n\n\n","category":"method"},{"location":"api.html#QuantumGaussianDynamics.update_weights!-Union{Tuple{T}, Tuple{QuantumGaussianDynamics.Ensemble{T}, QuantumGaussianDynamics.WignerDistribution{T}}} where T<:AbstractFloat","page":"API","title":"QuantumGaussianDynamics.update_weights!","text":"Update the weights of the ensemble according with the new wigner distribution\n\n\n\n\n\n","category":"method"},{"location":"index.html#QuantumGaussianDynamics.jl-Development-Documentation","page":"Home","title":"QuantumGaussianDynamics.jl Development Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Perform the quantum dynamics of a Gaussian wave-packet solving the equation of motion of the Time-Dependent Self-Consistent Harmonic Approximation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The code is written in julia to achieve high performance.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that this documentation is under development and may not be complete.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To use it, you must first install the cellconstructor routing from the sscha code. NB for compatibility issues with the cellconstructor code, it is necessary to install Python 3.10.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"conda create -n sscha -c conda-forge python=3.10 gfortran libblas lapack openmpi openmpi-mpicc pip numpy scipy spglib=2.2 setuptools=64\nconda activate sscha\npip install ase mpi4py\npip install cellconstructor python-sscha tdscha","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Clone the folder locally","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone git@github.com:NonequilibriumQuantumGaussianDynamics/QuantumGaussianDynamics.jl.git","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and instantiate the package","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia --project=/path/to/QuantumGaussianDynamics","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.instantiate()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will create a file named Manifesttoml contaning the current state of the environment.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Sometimes the default python used by PyCall is different with respect to the main one on which all the packages are installed. This can be checked with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia; using PyCall; PyCall.python","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"if the output is different to that of ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which python","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"then the pkg PyCall should be rebuild as","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ENV[\"PYTHON\"] = \"[path to the right python]\"\nimport Pkg\nPkg.build(\"PyCall\")","category":"page"},{"location":"index.html#Simulation-setup","page":"Home","title":"Simulation setup","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To run a TD-SCHA simulation, we need the following steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Setup the configuration variables: time-step, total simulation time, number of configurations, etc.\nLoad the initial conditions (e.g. the Gaussian distribution encoded via a dynamical matrix)\nSetup the calculator for interatomic energies and forces\nSetup the external force (electric field, etc)\nSetup the symmetries of the system + external force (optional)\nRun the dynamics","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"These steps will be discussed in details in the next subsections","category":"page"},{"location":"index.html#Setup-the-configuration-variables","page":"Home","title":"Setup the configuration variables","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To perform a dynamics, we need a configuration variables called Dynamics. Here we specify the total simulation time, time-step and number of configurations, as well as other properties of the integration.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"settings = QuantumGaussianDynamics.Dynamics(\n    dt = 0.1,\n    total_time = 10.0,\n    algorithm = 'generalized-verlet',\n    kong_liu_ratio = 1.0,\n    verbose = true,\n    evolve_correlators = true,\n    save_filename = method,\n    save_correlators = true,\n    save_each = 1,\n    N = 100,\n    seed = 1254,\n    correlated = true,\n)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See Dynamics for details on creating the initial Wigner distribution from a CellConstructor dynamical matrix.","category":"page"},{"location":"index.html#Load-the-initial-conditions-(dynamical-matrix)","page":"Home","title":"Load the initial conditions (dynamical matrix)","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The TD-SCHA evolves starting from a initial equilibrium Gaussian distribution, obtained by solving the Stochastic Self-Consistent Harmonic Approximation (SSCHA). For details on how to obtain this solution, see the SSCHA package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Here, we assume you already obtained a dynamical matrix and want to use it to initialize the TD-SCHA dynamics. For this, we use PyCall to load the dynamics using a python calculator","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using PyCall\ncc = pyimport(\"cellconstructor\")\nPH = pyimport(\"cellconstructor.Phonons\")\n\n# Load the dynamical matrix using cellconstructor from python\ndyn = PH.Phonons(\"dynfile\", nqirr=1)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more details on how to load the dynamical matrix, see the cellconstructor documentation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The dynamical matrix as a python object can be converted into a Wigner distribution for TD-SCHA using the following function","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using QuantumGaussianDynamics\n\ntemperature = 300.0 #K\n\n# Convert the python dynamical matrix into a Wigner distribution\nrho = init_from_dyn(dyn, temperature, settings)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the following, the API for the function init_from_dyn is shown See init_from_dyn for details.","category":"page"},{"location":"index.html#Initialize-the-forces-calculator","page":"Home","title":"Initialize the forces calculator","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The force calculator can be initialized using the ASE interface. If ase_calculator is a valid PyObject representing an ASE calculator, the following code initializes the forces calculator.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"\ncrystal = QuantumGaussianDynamics.init_calculator(ase_calculator, rho, ase.Atoms)","category":"page"},{"location":"index.html#External-force","page":"Home","title":"External force","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"External forces are introduced in the dynamics as ExternalPerturbation objects. The code introduces few kinds of such perturbations, like IR electric fields, Raman lasers, etc. The important thing is that the perturbation must be a subtype of ExternalPerturbation and must implement the method get_external_forces defined as","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"get_external_forces(time :: T, perturbation :: ExternalPerturbation, wigner :: WignerDistribution{T}) :: Vector{T} where {T}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It must return a vector of size n_dims * n_atoms, with the external force acting on each atom at the given time. All quantities must be expressed in Rydberg atomic units.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"One type of external perturbations is already implemented: ElectricField. There are several pulse shapes available in pulse. Here is an example of a pulse with a Gaussian wave-packet shape.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"\n# Equation of the pulse: E(t)=A*cos(2\\pi*freq*t)*exp(-(t-t0)^2/(2*sig^2))\nA = 3000.0 #kV/cm\nfreq = 2.4 #THz\nt0 = 1875.0 #fs\nsig = 468.0 #fs\nedir = [0,0,1.0] \nfield_fun = QuantumGaussianDynamics.pulse\nfield_f = t -> field_fun(t,A,freq,t0,sig)\n","category":"page"},{"location":"index.html#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"}]
}
